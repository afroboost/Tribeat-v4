// Tribeat Database Schema
// PostgreSQL avec Prisma ORM

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// ========================================
// USERS & AUTHENTICATION
// ========================================

enum UserRole {
  SUPER_ADMIN
  COACH
  PARTICIPANT
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  password  String // Hashé avec bcrypt
  role      UserRole @default(PARTICIPANT)
  avatar    String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  coachedSessions         Session[]            @relation("CoachSessions")
  sessionRoles            SessionParticipant[]
  messages                ChatMessage[]
  transactions            Transaction[]
  accesses                UserAccess[]
  promoCodesCreated       PromoCode[]          @relation("PromoCodesCreated")
  promoRedemptions        PromoRedemption[]
  freeAccessGrants        FreeAccessGrant[]    @relation("FreeAccessGrantsUser")
  freeAccessGrantsGranted FreeAccessGrant[]    @relation("FreeAccessGrantsGrantedBy")
  freeAccessGrantsRevoked FreeAccessGrant[]    @relation("FreeAccessGrantsRevokedBy")
  coachWallet             CoachWallet?
  sessionPayments         SessionPayment[]
  ledgerEntries           LedgerEntry[]

  @@index([email])
}

// ========================================
// SESSIONS LIVE
// ========================================

enum SessionStatus {
  SCHEDULED
  LIVE
  COMPLETED
  CANCELLED
}

enum MediaType {
  VIDEO
  AUDIO
  IMAGE
}

model Session {
  id          String  @id @default(cuid())
  title       String
  description String?
  coachId     String
  coach       User    @relation("CoachSessions", fields: [coachId], references: [id], onDelete: Cascade)

  // Média synchronisé
  mediaUrl  String? // URL Cloudinary / Vercel Blob ou externe
  mediaType MediaType?

  // Planification
  scheduledAt DateTime
  startedAt   DateTime?
  endedAt     DateTime?
  status      SessionStatus @default(SCHEDULED)

  // Métadonnées
  maxParticipants Int?
  isPublic        Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  participants     SessionParticipant[]
  messages         ChatMessage[]
  offers           Offer[]
  accesses         UserAccess[]
  promoCodes       PromoCode[]
  freeAccessGrants FreeAccessGrant[]
  promoRedemptions PromoRedemption[]
  sessionPayments  SessionPayment[]

  @@index([coachId])
  @@index([status])
  @@index([scheduledAt])
}

// ========================================
// MANY-TO-MANY : USER ↔ SESSION
// ========================================

enum ParticipantRole {
  COACH
  PARTICIPANT
  MODERATOR
}

model SessionParticipant {
  id        String          @id @default(cuid())
  userId    String
  sessionId String
  role      ParticipantRole @default(PARTICIPANT)
  joinedAt  DateTime        @default(now())
  leftAt    DateTime?

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  session Session @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@unique([userId, sessionId])
  @@index([sessionId])
  @@index([userId])
}

// ========================================
// CHAT EN TEMPS RÉEL
// ========================================

model ChatMessage {
  id        String   @id @default(cuid())
  sessionId String
  userId    String
  content   String
  timestamp DateTime @default(now())

  session Session @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([sessionId])
  @@index([timestamp])
}

// ========================================
// UI SETTINGS (THÈME DYNAMIQUE)
// ========================================

enum SettingCategory {
  THEME
  PWA
  GENERAL
}

model UI_Settings {
  id        String          @id @default(cuid())
  key       String          @unique
  value     String
  category  SettingCategory
  updatedAt DateTime        @updatedAt

  @@index([category])
}

// ========================================
// TRADUCTIONS (i18n EN BASE)
// ========================================

enum Language {
  FR
  EN
  DE
}

model Translation {
  id        String   @id @default(cuid())
  key       String // Ex: "session.join_button"
  language  Language
  value     String
  updatedAt DateTime @updatedAt

  @@unique([key, language])
  @@index([language])
}

// ========================================
// OFFERS (PRODUITS PAYANTS)
// ========================================

model Offer {
  id          String   @id @default(cuid())
  name        String
  description String?
  price       Int // En centimes (1000 = 10.00 CHF)
  currency    String   @default("CHF")
  sessionId   String? // Lié à une session spécifique (optionnel)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  session      Session?      @relation(fields: [sessionId], references: [id], onDelete: SetNull)
  transactions Transaction[]

  @@index([sessionId])
  @@index([isActive])
}

// ========================================
// TRANSACTIONS (STRIPE / MANUAL)
// ========================================

enum TransactionProvider {
  MANUAL
  STRIPE
  PAYSTACK
}

enum TransactionStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

model Transaction {
  id           String              @id @default(cuid())
  userId       String
  offerId      String?
  amount       Int // En centimes (ex: 1000 = 10.00 CHF)
  currency     String              @default("CHF")
  provider     TransactionProvider
  providerTxId String? // Stripe Session ID / Checkout ID
  status       TransactionStatus   @default(PENDING)
  metadata     Json? // Données additionnelles
  createdAt    DateTime            @default(now())
  updatedAt    DateTime            @updatedAt

  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  offer          Offer?          @relation(fields: [offerId], references: [id], onDelete: SetNull)
  userAccess     UserAccess?
  sessionPayment SessionPayment?
  ledgerEntries  LedgerEntry[]

  @@index([userId])
  @@index([offerId])
  @@index([status])
  @@index([providerTxId])
}

enum LedgerEntryType {
  PLATFORM_REVENUE
  COACH_EARNING
  PAYOUT
}

model LedgerEntry {
  id            String          @id @default(cuid())
  type          LedgerEntryType
  amount        Int // signed cents (+credit / -debit)
  currency      String          @default("CHF")
  userId        String?
  transactionId String?
  createdAt     DateTime        @default(now())

  user        User?        @relation(fields: [userId], references: [id], onDelete: SetNull)
  transaction Transaction? @relation(fields: [transactionId], references: [id], onDelete: SetNull)

  // Idempotence: at most 1 entry per transaction per type
  @@unique([transactionId, type])
  @@index([type])
  @@index([userId])
  @@index([transactionId])
  @@index([createdAt])
}

// ========================================
// WALLET & MONEY FLOW (FOUNDATION ONLY)
// ========================================

model CoachWallet {
  id              String   @id @default(cuid())
  coachId         String   @unique
  availableAmount Int      @default(0) // cents
  pendingAmount   Int      @default(0) // cents
  paidAmount      Int      @default(0) // cents (future payouts)
  currency        String   @default("CHF")
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  coach User @relation(fields: [coachId], references: [id], onDelete: Cascade)

  @@index([coachId])
}

model PlatformWallet {
  // Singleton
  id              String   @id @default("platform")
  balance         Int      @default(0) // cents
  totalCommission Int      @default(0) // cents
  currency        String   @default("CHF")
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

enum WalletOwnerType {
  PLATFORM
  COACH
}

enum WalletLedgerSource {
  SESSION_PAYMENT
  SUBSCRIPTION
  MANUAL
}

enum WalletLedgerDirection {
  CREDIT
  DEBIT
}

enum WalletLedgerReferenceType {
  TRANSACTION
  SESSION
}

model WalletLedger {
  id            String                    @id @default(cuid())
  ownerType     WalletOwnerType
  ownerId       String? // NULL for PLATFORM
  source        WalletLedgerSource
  direction     WalletLedgerDirection
  amount        Int // cents
  currency      String                    @default("CHF")
  referenceType WalletLedgerReferenceType
  referenceId   String
  createdAt     DateTime                  @default(now())

  // Hard idempotence for ledger entries per reference
  @@unique([ownerType, ownerId, source, direction, referenceType, referenceId])
  @@index([ownerType, ownerId])
  @@index([source])
  @@index([referenceId])
  @@index([createdAt])
}

enum SessionPaymentStatus {
  PENDING
  PAID
  FAILED
}

model SessionPayment {
  id            String @id @default(cuid())
  sessionId     String
  participantId String
  transactionId String @unique

  amount      Int // cents
  platformCut Int // cents
  coachCut    Int // cents
  currency    String               @default("CHF")
  status      SessionPaymentStatus @default(PENDING)

  paidAt            DateTime?
  releasedToCoachAt DateTime? // set when session ends and pending -> available
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  session     Session     @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  participant User        @relation(fields: [participantId], references: [id], onDelete: Cascade)
  transaction Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)

  @@index([sessionId])
  @@index([participantId])
  @@index([status])
  @@index([paidAt])
  @@index([releasedToCoachAt])
}

// ========================================
// USER ACCESS (ACCÈS PAYANTS)
// ========================================

enum AccessStatus {
  PENDING
  ACTIVE
  EXPIRED
  REVOKED
}

model UserAccess {
  id            String       @id @default(cuid())
  userId        String
  sessionId     String? // Accès à une session spécifique
  offerId       String? // Lié à une offre
  transactionId String?      @unique
  status        AccessStatus @default(PENDING)
  grantedAt     DateTime     @default(now())
  expiresAt     DateTime? // Null = permanent
  revokedAt     DateTime?
  revokedBy     String? // ID admin qui a révoqué

  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  session     Session?     @relation(fields: [sessionId], references: [id], onDelete: SetNull)
  transaction Transaction? @relation(fields: [transactionId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([sessionId])
  @@index([status])
}

// ========================================
// LIVE SESSION STATE (TEMPS RÉEL PERSISTÉ)
// ========================================

model LiveSessionState {
  id        String @id @default(cuid())
  sessionId String @unique

  // État de lecture
  isPlaying   Boolean @default(false)
  currentTime Float   @default(0) // Position en secondes
  volume      Int     @default(80) // 0-100

  // Métadonnées
  lastEventBy String? // ID du coach qui a émis le dernier event
  lastEventAt DateTime @default(now())

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([sessionId])
}

// ========================================
// PROMO CODES + FREE ACCESS (PHASE 1)
// ========================================

enum PromoCodeType {
  FULL_FREE
  PERCENT
  FIXED
}

model PromoCode {
  id             String        @id @default(cuid())
  code           String        @unique
  type           PromoCodeType @default(FULL_FREE)
  description    String?
  isActive       Boolean       @default(true)
  startsAt       DateTime?
  endsAt         DateTime?
  maxRedemptions Int?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  // Scope (optional): null => accès global
  sessionId String?
  session   Session? @relation(fields: [sessionId], references: [id], onDelete: SetNull)

  // Audit
  createdById String?
  createdBy   User?   @relation("PromoCodesCreated", fields: [createdById], references: [id], onDelete: SetNull)

  // Relations
  redemptions PromoRedemption[]

  @@index([isActive])
  @@index([startsAt])
  @@index([endsAt])
  @@index([sessionId])
  @@index([createdById])
}

model PromoRedemption {
  id          String        @id @default(cuid())
  promoCodeId String
  userId      String
  redeemedAt  DateTime      @default(now())
  promoType   PromoCodeType
  sessionId   String?

  promoCode PromoCode @relation(fields: [promoCodeId], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  session   Session?  @relation(fields: [sessionId], references: [id], onDelete: SetNull)

  // 1 utilisation / user / code (Phase 1)
  @@unique([promoCodeId, userId])
  @@index([userId])
  @@index([promoCodeId])
  @@index([redeemedAt])
  @@index([promoType])
  @@index([sessionId])
}

enum FreeAccessGrantSource {
  ADMIN
}

model FreeAccessGrant {
  id        String                @id @default(cuid())
  userId    String
  sessionId String? // null => accès global
  source    FreeAccessGrantSource
  reason    String?
  grantedAt DateTime              @default(now())
  expiresAt DateTime?
  revokedAt DateTime?

  // Audit (ADMIN grant/revoke)
  grantedById String?
  revokedById String?

  user      User     @relation("FreeAccessGrantsUser", fields: [userId], references: [id], onDelete: Cascade)
  session   Session? @relation(fields: [sessionId], references: [id], onDelete: SetNull)
  grantedBy User?    @relation("FreeAccessGrantsGrantedBy", fields: [grantedById], references: [id], onDelete: SetNull)
  revokedBy User?    @relation("FreeAccessGrantsRevokedBy", fields: [revokedById], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([sessionId])
  @@index([source])
  @@index([grantedAt])
  @@index([expiresAt])
  @@index([revokedAt])
  @@index([grantedById])
  @@index([revokedById])
}
